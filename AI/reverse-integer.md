# Reverse Integer 题解

## 问题描述

给定一个 32 位有符号整数，将每一位的数字反序

例1：

```
输入：123
输出：321
```

例2：

```
输入：-123
输出：-321
```

例3：

```
输入：120
输出：21
```

注意：

假设我们使用的是 32 位系统，且只能处理 $[-2^{31},2^{31}-1]$ 范围的整数，当出现整型溢出时，你的程序返回 0

## 解题思路

首先这道题不适合使用 Python 来做，原因是面对负数时，Python 的行为与期望不符，例如

```
>>> -31/10
-3.1
>>> -31%10
9
```

而使用 C++ 这样的语言，你会得到这样的结果

```
int main() {
	cout << "-3 / 10 = " << -3/10 << endl; 
	cout << "-3 % 10 = " << -3%10 << endl; 
}
输出：
-3 / 10 = 0
-3 % 10 = -3
```

可以看到后者比较符合我们的预期。

另外此题的关键在于如何解决整数溢出，思路如下：

**整数溢出不能在发生了之后才去判断，而只能在发生溢出之前判断**，我们的算法是，将原数不断除以 10，把得到的余数再不断乘以 10 ，这样就可以将原数「反转」，我们可以形象的把除以 10 看作是数的右移，而把乘以 10 看做是数的左移；既然要在溢出之前判断，那么我们就需要先将整型的最大值或最小值除以 10，然后将结果和该值进行比较，如果发现进一步操作会发生溢出，则返回 0。



对于正数，我们知道其最大值是 $2^{31}-1=2147483647$ ，所以如果结果 $y$ 在下一次「左移」前大于 214748364，那么就一定会发生溢出；特殊情况是 $y$ 在「左移」前等于 214748364，此时还需要判断下一个余数是否超过 7，如果超过，也可以判断其会发生溢出。

同理，负数也可以这样进行判断，这样我们就可以写出程序了：

```java
#include <iostream>
#include <climits>
using namespace std;

int integer_reverse(long x) {
    int result = 0;
    while (x != 0) {
        int remainder = x % 10;
        x = x / 10;

        if (result > INT_MAX/10 || (result == INT_MAX/10 && remainder > 7)) return 0;
        if (result < INT_MIN/10 || (result == INT_MIN/10 && remainder < -8)) return 0;

        result = result * 10 + remainder;
    }

    return result;
}
```

可以看到，两个 `if` 语句分别处理正数和负数两种情况，而 `if` 中的条件就包含了刚才说的两种溢出情况。



原题链接：https://leetcode.com/problems/reverse-integer/
