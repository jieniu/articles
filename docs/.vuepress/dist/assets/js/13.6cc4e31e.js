(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{177:function(s,a,e){"use strict";e.r(a);var n=e(0),t=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var s=this,a=s.$createElement,e=s._self._c||a;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"虚析构函数和智能指针"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚析构函数和智能指针","aria-hidden":"true"}},[s._v("#")]),s._v(" 虚析构函数和智能指针")]),s._v(" "),e("h2",{attrs:{id:"虚析构函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚析构函数","aria-hidden":"true"}},[s._v("#")]),s._v(" 虚析构函数")]),s._v(" "),e("p",[s._v("当我们想在程序中实现多态时，我们经常会这样做：")]),s._v(" "),e("div",{staticClass:"language-C++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('#include <iostream>\nusing namespace std;\nclass Dog {\npublic:\n  Dog() {}\n  ~Dog() { cout << "Dog destroy\\n";}\n};\n\nclass YellowDog : public Dog {\npublic:\n  YellowDog() {}\n  ~YellowDog() { cout << "YellowDog destroy\\n";}\n  static Dog* createDog() { return new YellowDog(); }\n};\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br")])]),e("p",[s._v("即用工厂类或工厂方法来创建具体的对象，而在运行时通过对基类（这里是Dog）的指针或引用来实现对不同子类（这里是YellowDog）的调用，这样我们就实现了「多态」。不过，上面代码是有问题的，你可以看下面代码的输出：")]),s._v(" "),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("int main(int argc, char** argv) {\n  Dog* dog = YellowDog::createDog();\n  delete dog;\n  return 0;\n}\n----<output>----\nDog destroy\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br")])]),e("p",[s._v("从输出结果可以看出，"),e("code",[s._v("delete dog")]),s._v(" 时，只调用了基类的析构函数，而子类对象没有被析构，此时很可能会发生内存泄露，为了避免这种情况，我们需要在基类析构函数前加上 "),e("code",[s._v("virtual")]),s._v(" 关键字，如下")]),s._v(" "),e("div",{staticClass:"language-C++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('virtual ~Dog() { cout << "Dog destroy\\n"; }\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("接着重新编译后再运行程序，便可以看到子类对象被如期析构了")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("----<output>----\nYellowDog destroy\nDog destroy\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("h2",{attrs:{id:"用智能指针-shared-ptr-实现动态析构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用智能指针-shared-ptr-实现动态析构","aria-hidden":"true"}},[s._v("#")]),s._v(" 用智能指针 shared_ptr 实现动态析构")]),s._v(" "),e("p",[s._v("从 C++ 11 起，通过 "),e("code",[s._v("shared_ptr")]),s._v(" 你同样可以实现动态析构，"),e("code",[s._v("shared_ptr")]),s._v(" 定义在头文件 "),e("code",[s._v("<memory>")]),s._v(" 中")]),s._v(" "),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("template< class T > class shared_ptr;\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("下面我们就来看下智能指针的版本")]),s._v(" "),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('class Dog {\npublic:\n  Dog(){}\n  ~Dog() { cout << "Dog destructor" << endl; }\n};\n\nclass YellowDog : public Dog {\npublic:\n  YellowDog() {}\n  ~YellowDog() { cout << "YellowDog destructor" << endl; }\n\n  static shared_ptr<Dog> createDog() {\n      return shared_ptr<YellowDog>(new YellowDog());\n  }\n};\n\nint main() {\n    shared_ptr<Dog> p = YellowDog::createDog();\n    return 0;\n}\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br")])]),e("p",[s._v("从输出中可以看到虽然 "),e("code",[s._v("Dog")]),s._v(" 类中的析构函数没有声明 "),e("code",[s._v("virtual")]),s._v("，但 "),e("code",[s._v("YellowDog")]),s._v(" 的析构函数仍然被顺利调用了。")]),s._v(" "),e("p",[e("em",[s._v("注意："),e("code",[s._v("STL")]),s._v(" 中的所有类都没有 "),e("code",[s._v("virtual")]),s._v(" 析构函数，所以当你从 "),e("code",[s._v("STL")]),s._v(" 中派生子类时，要尽可能的使用 "),e("code",[s._v("shared_ptr")])]),s._v("。")]),s._v(" "),e("p",[s._v("参考：https://www.youtube.com/watch?v=ZiNGWHg5Z-o&index=6&list=PLE28375D4AC946CC3")])])}],!1,null,null,null);t.options.__file="virtual_destructor.md";a.default=t.exports}}]);