# 编译器产生的默认成员函数（Compiler Generated Functions）

在 C++03 中，定义以下类，

```
class Dog {};
```

编译器会给你产生 4 个默认的成员函数：

1. 复制构造函数（Copy constructor）
2. 赋值操作符（Copy Assignment Operator）
3. 析构函数（Destructor）
4. 默认构造函数（Default constructor），注意：**默认构造函数只有在你没有声明任何构造函数的情况下才产生**

上面的代码和下面的代码等价

```
Class Dog {
public:
	Dog(const Dog& rhs) {...}; 				// 挨个成员初始化
	Dog& operator=(const Dog& rhs) {...}; 	 // 挨个成员拷贝
	Dog() {...}; 		// 1. 调用基类的构造函数
					   // 2. 调用成员的默认构造函数
	~Dog() {...}; 	    // 1. 调用基类的析构函数;
				 	   // 2. 调用成员的析构函数;
};
```

以上代码产生时，有两点需要注意

1. 编译器产生的默认函数都是 `public`、 `inline` 的
2. 只有在需要的时候，编译器才会产生它们
  

上面提到了默认构造函数这个概念，我们先来回顾一下，什么是默认构造函数，它的特征是**默认构造函数可以在没有任何参数的情况下使用**，这里有个例子需要记一下：如果构造函数的所有参数都有默认参数，那么这个构造函数也可以作为默认构造函数使用。



C++ 中的容器是经常被用到的模板类库，**使用容器的类需要具备两个条件：支持复制操作和赋值构造**，即它应包含复制操作符和赋值构造函数，而如果类中又包含引用类型的成员，或 `const` 成员，由于这些成员无法被复制，所以这些类对象无法使用容器。



既然是规则，那一定有它无法生效的情况：

1. 什么情况下编译器无法创建默认构造函数？

   如果类定义了构造函数，且该构造函数带参（不是默认构造函数）；如果成员或基类无法创建默认构造函数，或没有默认构造函数。 

2. 什么情况下编译器无法创建赋值操作符？

   类中含有 `const` 或引用类型的成员

3. 什么情况下编译器无法创建析构函数？

   如果基类的析构函数在 `private` 中



例子：以下代码有什么问题？

```
class Dog {
    string& name_;
};

int main() {
    Dog dog; 
}
```

编译错误：

```
error: implicit default constructor for 'Dog' must explicitly initialize the reference member
```

因为默认构造函数在构造 `name_` 时，只能构造，而无法初始化，**而 C++ 要求引用被初始化，因为引用无法被重复赋值。**



C++11 引入了 `default` 关键字，它可以显示的告知编译器，为此类产生默认的成员函数，例如它和默认构造函数一起使用，作用是：即便定义了其他有参构造函数，仍然让编译器为此类产生一个默认构造函数，如下：

```
class Dog {
public:
	Dog() = default; 
	Dog(string name) {...}
};
int main() {
    Dog dog;
}

----
g++ -std=c++11 -c dog.cc // it's ok
```



总结一下：本文介绍了

1. 在 C++03 中，编译器会为类产生哪些默认的成员函数
2. 所有参数都有默认参数的构造函数也是默认构造函数
3. 要使用容器，类需要具备可复制和可赋值构造两个特性
4. 如果类中有 `const` 成员和引用类型的成员，则该类无法赋值和赋值构造
5. 如果基类中的析构函数在 `private` 中，则编译器不会给子类产生默认析构函数
6. 如果你定义了其他带参构造函数，则编译器不会给你产生默认构造函数，除非你使用 C++11 中的 `default` 关键字


参考：

* [Advanced C++: Compiler Generated Functions](https://www.youtube.com/watch?v=KMSYmY74AEs&t=250s)
