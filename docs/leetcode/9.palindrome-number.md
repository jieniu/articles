# [LeetCode] 9. Palindrome Number 题解

## 问题描述

判断某个数是否为回文数字。回文数字的特点是从左到右读这个数，和从右到左读这个数，得到的结果一样。

**例 1:**

```
输入: 121
返回: true
```

**例 2:**

```
输入: -121
返回: false
解释: 从左到右读为 -121， 但从右到左读为 121-，所以它不是回文。
```

**例 3:**

```
输入: 10
输出: false
解释: 从右到左读为 01，所以它不是回文。
```

## 问题难度

**`Easy`**

## 解题思路

虽然该题为简单难度，但要做对并不容易，我也是提交了好几次才成功，主要问题在于边界条件判断错误。

判断一个数字是否是回文，第一直觉便是将这个数反转，最高位和最低位互换，以此类推，得到的新数和原数比较，如果相等，便可以证明该数是回文。但这里有可能会产生整型溢出的问题，例如在 32 位环境下，2147483647 被完全反转后，得到的数字为 -1126087180 (而不是预期中的 7463847412)。

所以这种方法需要改进。更好的思路是只对一半的位数进行调整，然后和剩下的数进行比较，如果相等，也可以认为它是回文。

例如：123321 这个数，我们将低位到中间位的 321 反转，可以得到 123，和剩下的高位 123 进行比较，它们正好相等。

剩下几个边界条件就比较简单了

* 负数肯定不是回文
* 能被 10 整除的数不是回文

经过以上分析，便可以写代码了：

```C++
class Solution {
public:
    bool isPalindrome(int x) {
        if (x < 0 || (x > 0 && x % 10 == 0)) {
            return false;
        }
        
        int num = 0;
        while (num < x) {
            num = num * 10 + x % 10;
            x = x / 10;
        }
        
        if (x == num || num / 10 == x) {
            return true;
        }
          
        return false;
    }
};
```



[原题链接](https://leetcode.com/problems/palindrome-number/)