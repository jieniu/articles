# [LeetCode] 1. Two Sum 题解

## 问题描述

给定一个整数数组 `nums ` 和一个目标数字 `target`，要求返回数组中两个数字的**下标**，且这两个数字加起来等于目标数字 `target`

你可以假设每组输入将会有一个解决方案，且数组中同一个数字只能使用一次

**例子：**

```
输入 nums = [2, 7, 11, 15], target = 9,
因为 nums[0] + nums[1] = 2 + 7 = 9,
所以 return [0, 1]。
```

## 问题难度

**`Easy`**

## 解题思路

期望遍历一遍数组，就可以找到两个符合条件的数字，遍历过程中，每读到一个数字，需要完成两个动作：

1. 查询「补数集合」，判断该数字的「补数」（目标数字减去该数）是否存在，如果存在，则返回补数和该数的下标
2. 如果不存在，那么该数很可能是别的数的「补数」，将该数和下标放入「补数集合」中

可以看到「补数集合」是这里的关键，它要以尽可能快的速度完成：

1. 查询某个补数是否存在
2. 插入一个补数

这两个操作。

而我们都知道，对于这种需求，有一种数据结构可以达到 $O(1)$ 的时间复杂度，那就是哈希表，说到这里，我们就可以动手写代码了：

```python
class Solution(object):    
    def twoSum(self, nums, target):
        complements = {}
        for i, x in enumerate(nums):
            if target - x in complements:
                return [complements[target - x], i]
            complements[x] = i
```

以上，`complements` 是我们的「补数集合」，在 Python 中，字典（dict）数据结构就是用哈希表实现的，所以这里 `complements`  就定义为一个字典。

第 4 行我们依次遍历数组

第 5、6 行用来判断当前数的「补数」是否存在，如果存在则返回「补数」所在的下标和当前数的下标

第 7 行是在「补数」不存在的情况下，将当前数作为其他数的「补数」，连同下标一起插入到「补数集合」中

于是，上面代码就实现了通过遍历一次数组，就可以找到符合条件的两个数的下标，时间复杂度为 $O(n)$ 。



[原题链接](https://leetcode.com/problems/two-sum/)


